# Copyright 2016 Kim. All right reserved.

#------------------------------------------------------------------------------
# checkData checks data to judge whether it is good to use or not
#
# TODO(kim.seonghyun) : Fix error handling from validity to error throwing
# TODO(kim.seonghyun) : checkData is TOO long
#
# Author: kim.seonghyun@scipi.net (Kim Seonghyun)
#
#------------------------------------------------------------------------------

MIN.REFERENCE.SESSIONS <- 1
MIN.MEASUREMENT.SESSIONS <- 1
MIN.NROWS <- 20 # at least five hours
MIN.NTRAFFICS <- 10 # at least 10 out of 30 traffic events
ERR.NOTENOUGH.ROWS <- "ERR.NOTENOUGH.ROWS"
ERR.NOTENOUGH.COLS <- "ERR.NOTENOUGH.COLS"
ERR.SD.LOW <- "ERR.SD.LOW"
ERR.Y.IS.NA <- "ERR.Y.IS.NA"

#' Join data tables
#'
#' Creates data frame for prediction that follows tidy-timexseries-data format.
#'
#' @param .dep.data A data table that contains Y values, only one y_i will be
#'        selected by \code{.dep.colname}
#' @param .indep.data A data table that continas X values
#' @param .dep.colname One columename since n(y) = 1
data_join <- function(.dep.data,
                      .indep.data,
                      .dep.colname) {

  stopifnot(.dep.colname %in% colnames(.dep.data))

  ret <- .dep.data %>%
         select(Datetime, Date, matches(.dep.colname)) %>%
         left_join(.indep.data) %>%
         .[complete.cases(.), ]

  # TODO(kim.seonghyun): Define its own class name
  # class(ret) <- "notyet"

  return(ret)
}

#' Check data table
#'
#' @param .data A tidy-timeseries data generated from \code{data_join}
#' @param plan A plan that generated by \code{planner}
checkData <- function(.data, plan) {
  # Checks the analysis plan suppied to \code{ZDSAD}.
  # It finds indices of training and measurement periods, and joins independent
  # and dependent variables.
  # e.g.) ("xxxx-xx-xx 00:00:00", "xxxx-xx-xx 23:45:00") -> c(1, 96)
  # e.g.) (Date | KPI A) && (Date | traffic 1 | traffic 2)
  #       -> (Date | KPI A | traffic 1 | traffic 2)
  # Any record that has missing counters will be removed by using
  # \code{na.omit}.
  #
  # Args:
  #   .data: a data table that joins dependent and independent variables.
  #   plan: a list of data analysis plan

  # plan specifies how the data will be analysed, and will be checked
  # if this data is possible to be analysed or not. For example, KPI values can
  # be all zero.
  # e.g.) plan <- c(training.period = "2016-03-03",
  #                   measurement = "2016-03-02",
  #                   KPI = "CS_A_FAIL_RRC",
  #                   output.dir = paste0(jobParameters$htmlOutput,'/'),
  #                   num.models = 1)
  stopifnot('training.period' %in% names(plan))
  stopifnot('KPI' %in% names(plan))
  stopifnot(4 < ncol(.data)) # We need to have at least 1 i.v
  stopifnot('Datetime' == names(.data)[1])
  stopifnot('Date' == names(.data)[2])
  stopifnot(plan[["KPI"]] == names(.data)[3])

  KPI <- names(.data)[3] # 3rd column name is the name of KPI
  target.data <- .data %>% na.omit

  # finds indices of training periods
  training.period <- plan$training.period %>% as.character
  target.ref.dates <- target.data %>%
    filter(Date %>% magrittr::is_in(training.period)) %>%
    select(Datetime) %>% slice(c(1,n()))
  ref.idxs <- apply(target.ref.dates, 1, FUN = function(x) {
                 which(!is.na(match(target.data$Datetime, x)), arr.ind=TRUE)
              })

  if (any(is.null(ref.idxs), length(ref.idxs) != 2,
          ref.idxs[2] - ref.idxs[1] < MIN.NROWS)) {
      return(list(valid = FALSE, reason = "Trainingset error"))
  }

  # Finds indices of measurement periods
  if ('testing.period' %in% names(plan)) {
    measurement.period <- plan$testing.period %>% as.character
    target.mea.dates <- target.data %>%
      filter(Date %>% magrittr::is_in(measurement.period)) %>%
      select(Datetime) %>% slice(c(1,n()))
    mea.idxs <- apply(target.mea.dates, 1, FUN = function(x) {
                 which(!is.na(match(target.data$Datetime, x)), arr.ind=TRUE)
                })
    if (any(is.null(mea.idxs), length(mea.idxs) != 2,
            mea.idxs[2] - mea.idxs[1] < MIN.NROWS)) {
          return(list(valid = FALSE, reason = "Testset error"))
    }
  } else {
    # if the plan does not have any measurement periods, then
    # we can use only one single data point as measurement. This is useful for
    # variable selection
    mea.idxs <- c(ref.idxs[2], ref.idxs[2])
    ref.idxs <- c(ref.idxs[1], ref.idxs[2]-1)
  }

  # Reduce target data table and recalcuates indices
  target.data <- target.data %>%
    slice(c(ref.idxs[1]:ref.idxs[2], mea.idxs[1]:mea.idxs[2]))
  ref.idxs <- c(1, ref.idxs[2] - ref.idxs[1] + 1)
  mea.idxs <- c(ref.idxs[2] + 1, mea.idxs[2] - mea.idxs[1] + ref.idxs[2] + 1)

  # Assigns new variable for creatig figure
  time.points = as.POSIXct(as.matrix(target.data[,"Datetime"]))

  # Checks its validity before data analysis
  # Check if it is possible to estimate target.data or not
  # 1) less than 50 rows: not enough training data
  # 2) less than 4 columns: not enough independent variables
  # 3) sd == 0: this algorithm requires variarity in y value
  # 4) no na in y: the same reason as 4
  valid = TRUE
  reason = ""
  y <- target.data[,KPI] %>% t %>% as.vector

  tryCatch(
    {
      if (nrow(target.data) < 50) {
        valid = FALSE
        reason = ERR.NOTENOUGH.ROWS
      }
      if (ncol(target.data) < 5) {
        valid = FALSE
        reason = ERR.NOTENOUGH.COLS
      }

      if (all(is.na(y)) == TRUE) {
        valid = FALSE
        reason = ERR.Y.IS.NA
      }

      y.sd <- sd(y, na.rm = TRUE)
      if (any(!is.finite(y.sd),
              is.null(y.sd),
              all.equal(y.sd, 0)==TRUE)) {
        valid = FALSE
        reason = ERR.SD.LOW
      }
    },
    error = function(e) {
      stop(e)
    }
  )

  return(list(target.data = target.data %>% select(-Datetime, -Date),
              time.points = time.points,
              ref.idxs = ref.idxs,
              mea.idxs = mea.idxs,
              valid = valid,
              reason = reason))
}
