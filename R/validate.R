#' Validate data table
#'
#' @param .data A tidy-timeseries data generated from \code{data_join}
#' @param plan A plan that generated by \code{planner}
validate_data <- function(.data, plan) {
  # Checks the analysis plan suppied to \code{ZDSAD}.
  # It finds indices of training and measurement periods, and joins independent
  # and dependent variables.
  # e.g.) ("xxxx-xx-xx 00:00:00", "xxxx-xx-xx 23:45:00") -> c(1, 96)
  # e.g.) (Date | KPI A) && (Date | traffic 1 | traffic 2)
  #       -> (Date | KPI A | traffic 1 | traffic 2)
  # Any record that has missing counters will be removed by using
  # \code{na.omit}.
  #
  # Args:
  #   .data: a data table that joins dependent and independent variables.
  #   plan: a list of data analysis plan
  # TODO(kim.seonghyun) : Fix error handling from validity to error throwing
  # TODO(kim.seonghyun) : checkData is TOO long

  # plan specifies how the data will be analysed, and will be checked
  # if this data is possible to be analysed or not. For example, KPI values can
  # be all zero.
  # e.g.) plan <- c(training.period = "2016-03-03",
  #                   measurement = "2016-03-02",
  #                   KPI = "CS_A_FAIL_RRC",
  #                   output.dir = paste0(jobParameters$htmlOutput,'/'),
  #                   num.models = 1)
  stopifnot('training_period' %in% names(plan))
  stopifnot('target_name' %in% names(plan))
  stopifnot(4 < ncol(.data)) # We need to have at least 1 i.v
  stopifnot('Datetime' == names(.data)[1])
  stopifnot('Date' == names(.data)[2])
  stopifnot(plan[["target_name"]] == names(.data)[3])

  MIN.REFERENCE.SESSIONS <- 1
  MIN.MEASUREMENT.SESSIONS <- 1
  MIN.NROWS <- 20 # at least five hours
  MIN.NTRAFFICS <- 10 # at least 10 out of 30 traffic events
  ERR.NOTENOUGH.ROWS <- "ERR.NOTENOUGH.ROWS"
  ERR.NOTENOUGH.COLS <- "ERR.NOTENOUGH.COLS"
  ERR.SD.LOW <- "ERR.SD.LOW"
  ERR.Y.IS.NA <- "ERR.Y.IS.NA"

  KPI <- names(.data)[3] # 3rd column name is the name of KPI
  target.data <- .data %>% na.omit

  # finds indices of training periods
  training_period <- plan[["training_period"]] %>% as.character
  target.ref.dates <- target.data %>%
    filter(Date %>% magrittr::is_in(training_period)) %>%
    dplyr::select(Datetime) %>% slice(c(1,n()))
  ref.idxs <- apply(target.ref.dates, 1, FUN = function(x) {
                 which(!is.na(match(target.data$Datetime, x)), arr.ind=TRUE)
              })

  if (any(is.null(ref.idxs), length(ref.idxs) != 2,
          ref.idxs[2] - ref.idxs[1] < MIN.NROWS)) {
      return(list(valid = FALSE, reason = "Trainingset error"))
  }

  # Finds indices of measurement periods
  if ('testing_period' %in% names(plan)) {
    measurement_period <- plan[["testing_period"]] %>% as.character
    target.mea.dates <- target.data %>%
      filter(Date %>% magrittr::is_in(measurement_period)) %>%
      dplyr::select(Datetime) %>% slice(c(1,n()))
    mea.idxs <- apply(target.mea.dates, 1, FUN = function(x) {
                 which(!is.na(match(target.data$Datetime, x)), arr.ind=TRUE)
                })
    if (any(is.null(mea.idxs), length(mea.idxs) != 2,
            mea.idxs[2] - mea.idxs[1] < MIN.NROWS)) {
          return(list(valid = FALSE, reason = "Testset error"))
    }
  } else {
    # if the plan does not have any measurement periods, then
    # we can use only one single data point as measurement. This is useful for
    # variable selection
    mea.idxs <- c(ref.idxs[2], ref.idxs[2])
    ref.idxs <- c(ref.idxs[1], ref.idxs[2]-1)
  }

  # Reduce target data table and recalcuates indices
  target.data <- target.data %>%
    slice(c(ref.idxs[1]:ref.idxs[2], mea.idxs[1]:mea.idxs[2]))
  ref.idxs <- c(1, ref.idxs[2] - ref.idxs[1] + 1)
  mea.idxs <- c(ref.idxs[2] + 1, mea.idxs[2] - mea.idxs[1] + ref.idxs[2] + 1)

  # Assigns new variable for creatig figure
  time.points <- as.POSIXct(as.matrix(target.data[,"Datetime"]))

  # Checks its validity before data analysis
  # Check if it is possible to estimate target.data or not
  # 1) less than 50 rows: not enough training data
  # 2) less than 4 columns: not enough independent variables
  # 3) sd == 0: this algorithm requires variarity in y value
  # 4) no na in y: the same reason as 4
  valid = TRUE
  reason = ""
  y <- target.data[, KPI] %>% t %>% as.vector

  tryCatch({
      if (nrow(target.data) < 50) {
        valid = FALSE
        reason = ERR.NOTENOUGH.ROWS
      }
      if (ncol(target.data) < 5) {
        valid = FALSE
        reason = ERR.NOTENOUGH.COLS
      }

      if (all(is.na(y)) == TRUE) {
        valid = FALSE
        reason = ERR.Y.IS.NA
      }

      y.sd <- sd(y, na.rm = TRUE)
      if (any(!is.finite(y.sd),
              is.null(y.sd),
              all.equal(y.sd, 0)==TRUE)) {
        valid = FALSE
        reason = ERR.SD.LOW
      }
    },
    error = function(e) {
      stop(e)
  })

  res <- list(target.data = target.data %>% dplyr::select(-Datetime, -Date),
              time.points = time.points,
              ref.idxs = ref.idxs,
              mea.idxs = mea.idxs,
              valid = valid,
              reason = reason)
  class(res) <- "checked_data"
  return(res)
}

#' Validate priors
#'
validate_priors <- function(target_names, priors) {
  stopifnot(!missing(target_names))
  stopifnot(length(target_names) > 0)
  stopifnot(!is.null(priors))

  for (target_name in target_names) {
    prior <- priors[[target_name]]
    if (is.null(prior)) {
      prior <- priors[["default"]]
    }

    if (!"y_formula" %in% names(prior)) {
      if ("y_formula_file" %in% names(prior)) {
        prior[["y_formula"]] <- prior[["y_formula_file"]] %>% read.csv2
      } else {
        prior[["y_formula"]] <- priors[["default"]][["y_formula"]]
      }
    }

    if (!"X_formula" %in% names(prior)) {
      if ("X_formula_file" %in% names(prior)) {
        prior[["X_formula"]] <- prior[["X_formula_file"]] %>% read.csv2
      } else {
        prior[["X_formula"]] <- priors[["default"]][["X_formula"]]
      }
    }

    if (!"extract_patterns_in_Y" %in% names(prior)) {
      val <- priors[["default"]][["extract_patterns_in_Y"]]
      prior[["extract_patterns_in_Y"]] <- val
    }

    if (!"extract_patterns_in_X" %in% names(prior)) {
      val <- priors[["default"]][["extract_patterns_in_X"]]
      prior[["extract_patterns_in_X"]] <- val
    }

    priors[[target_name]] <- prior
  }

  return(priors)
}

#' Validate plan
#'
# TODO(kim.seonghyun): Implement this
